\hypertarget{implementace}{%
\chapter{Implementace}\label{implementace}}

V~poslední části této práce se zaměříme na implementační detaily webové aplikace. Implementaci představíme ve čtyřech částech, z~nichž se každá věnuje jiné buď obecnější oblasti nebo naopak konkrétnější funkcionalitě. V~rozsahu této práce tak není komentovat kód jako celek -- ten však lze dohledat jako přílohu přiloženou k~této práci.

\hypertarget{systuxe9m-modulux16f-a-komponent}{%
\section{Systém modulů a~komponent}\label{systuxe9m-modulux16f-a-komponent}}

Jelikož je naše aplikace založena na webovém frameworku React, drželi jsme se při tvorbě všech souborů standardní adresářové struktury. Jednotlivé reactí komponenty jsou umístěny v~adresáři \verb|components|, zde je jsou tedy soubory týkající se primárně UI konkrétních částí aplikace. Zbytek komponent je pak ve složce \verb|pages|, kde jsou izolovány stránky aplikace.

\dirtree{%
.1 src.
.2 assets.
.2 components.
.3 Dialogs.
.3 Entry.
.3 Form.
.3 Map.
.2 contexts.
.2 data.
.2 hooks.
.2 models.
.2 pages.
.2 utils.
}

Při tvorbě komponent jsme se snažili o~co největší modularitu z~hlediska funkcionalit jednotlivých částí. Níže uvádíme příklad komponenty \verb|Gallery|, která obsahuje logiku a~UI pro obrázkovou galerii.

Komponentu definujeme jako javaScriptovou funkci a~za vstupní parametr (objekt \emph{props}) vkládáme danou část dostupných dat typu \verb|GalleryProps| (jde o~seznam názvů souborů a~jejich případných popisků).

Na začátku probíhá inicializace vstupních dat, jimž předchází validace a~další procedury. V~příkladu si navíc můžeme všimnout využití takzvaných \emph{hooks} (reactí funkce, které začínají slovem \emph{use}, například tedy \verb|useState|), které typicky spravují stav komponenty.

\begin{verbatim}
const Gallery = ({ dropZone }: GalleryProps) => {
    const { urls, setNames } = useAsyncFiles();
    const [loading, setLoading] = useState<boolean>(true);
    
    const [images, setImages] = useState<
        {
            original: string | undefined;
            thumbnail: string | undefined;
            description: string | undefined;
        }[]
    >([]);
    
if (!dropZone.files[0]) return  <></>;
    ...
\end{verbatim}

Jelikož je komponenta \verb|Gallery| závislá na datech z~externí databáze, musí nejprve proběhnout stáhnutí požadovaných souborů. To probíhá prostřednictvím \verb|useEffect|, který se vždy spouští při změně hodnoty proměnné, která je definovaná na konci funkce v~takzvaném \emph{dependency array}.

Takto si komponenta na základě vstupních dat zavolá asynchronní funkci \verb|setNames| z~hooku \verb|useAsyncFiles| (ten je definován v~předchozí ukázce), která izolovaně komunikuje s~databází a~přiřazuje výsledné URL adresy souborů do proměnné \verb|urls|. Výhodou tohoto principu je nezávislost komponent na aktuálně používaném řešení pro stahování dat.

\begin{verbatim}
...
useEffect(() => {
  if (urls?.[0]) {
    const newImages = urls.map((url, i) => ({
      original: url,
      thumbnail: url,
      description: dropZone.names[i] ? .name
    }));
    setImages(newImages);
    setLoading(false);
  }
}, [urls]);

useEffect(() => {
  if (dropZone.files[0]) {
    setNames(dropZone.files);
  }
}, [dropZone]);
...
\end{verbatim}

Po inicializaci proměnné \verb|urls| je pak její obsah vložen do stavu komponenty, která s~ním posléze pracuje v~JSX (při využívání TypeScriptu TSX) zápisu níže. Ten slouží pro deklaraci UI prvků a~skládat se může jak z~klasických HTML značek, tak v~našem případě o~elementy z~UI knihovny Material UI\footnote{https://mui.com/}, která zajišťuje konzistentní vzhled napříč aplikací.

Na příkladu níže lze pěkně vidět deklarativní způsob zápisu -- \verb|ImageGallery| (tedy jiná vložená komponenta) je vykreslena pouze v~případě, pokud není aktivní proměnná \verb|loading|. Pokud aktivní je, vykreslí se komponenta načítání \verb|LoadingSpinner|, kterou jsme definovali na jiném místě aplikace.

Na této bázi jsou v~obecnosti postavené všechny námi vytvořené komponenty a~je tak zřejmé, že v~případě potřeby lze změnit zdrojový kód na jednom místě a~změny se projeví všude, kde je daná komponenta použita.

\begin{verbatim}
...
return (
        <>
            <Text variant="h3" component="h1" text="Obrázky" />
            {loading ? (
                <LoadingSpinner
                    boxWidth="100%"
                    height="5rem"
                    width="5rem"
                    textAlign="center"
                    pt="2rem"
                    pb="10rem"
                />
            ) : (
                <Box sx={{ mt: '3rem !important' }}>
                    <ImageGallery
                        lazyLoad
                        showPlayButton={false}
                        items={images as ReactImageGalleryItem[]}
                    />
                </Box>
            )}

            <Divider />
        </>
    );
\end{verbatim}

\hypertarget{ux159uxedzenuxed-stavu}{%
\section{Řízení stavu}\label{ux159uxedzenuxed-stavu}}

Komponenty si navzájem sice mohou vyměňovat libovolné množství dat, nicméně v~okamžiku, kdy se stává aplikace komplexnější, je zapotřebí přistupovat k~obecném stavu aplikace systematičtěji.

Takovým příkladem v~naší aplikaci mohou být aktivní filtry. Ty se sice nastavují na jednom konkrétním místě, jejich použití ale sahá do vícero různé zanořených komponent jako je komponenta s~mapou či seznam lokalit ve vysouvacím panelu. Proto je zapotřebí mít tento stav mimo komponenty na určitém místě uložen.

Pro tento účel v~naší aplikaci používáme takzvaný \emph{context}, který vychází přímo z~Reactu. Před jeho použitím je ho zapotřebí definovat nastavením hodnot a~jejich typů, jež má obsahovat. V~tomto případě ukládáme aktivní filtry \verb|activeFilters|, funkci, která je přenastavuje \verb|setActiveFilters| a~jednoduchou hodnotu znázorňující zapnuty/vypnutý stav \verb|isDisabled|.

V~rámci našeho contextu \verb|FilterContext| pak definujeme vlastní hook \verb|useFilter|, který má přístup do vytvořeného contextu. Ten pak právě využíváme jako vstup do daného stavu v~jiných komponentách.

\begin{verbatim}
...
type FilterContextType = {
    activeFilters: EntryFilters;
    setActiveFilters: Dispatch<SetStateAction<EntryFilters>>;
    isDisabled: boolean;
};

const FilterContext = createContext<FilterContextType>(undefined as never);

export const useFilter = () => useContext(FilterContext);
...
\end{verbatim}

Vlastní tělo contextu nazýváme \verb|FilterProvider|, které drží stavy zapnutých filtrů apod.

\begin{verbatim}
...
export const FilterProvider = ({ children }: { children: JSX.Element }) => {
    const [activeFilters, setActiveFilters] =
        useState<EntryFilters>(defaultFilterState);
    const [isDisabled, setDisabled] = useState<boolean>(true);

    useEffect(() => {
        setDisabled(isEqual(activeFilters, defaultFilterState));
    }, [activeFilters]);

    return (
        <FilterContext.Provider
            value={{
                activeFilters,
                setActiveFilters,
                isDisabled
            }}
        >
            {children}
        </FilterContext.Provider>
    );
};
\end{verbatim}

Využití contextu pak může vypadat v~jiné komponentě následovně.

\begin{verbatim}
...
const FilterList = ({
    setToggle
}: {
    setToggle: Dispatch<SetStateAction<boolean>>;
}) => {
    const { features } = useFeatures();
    const { activeFilters, setActiveFilters } = useFilter(); 
    ...
    \end{verbatim}

\hypertarget{komunikace-s-databuxe1zuxed}{%
\section{Komunikace s~databází}\label{komunikace-s-databuxe1zuxed}}

\hypertarget{mapa}{%
\section{Mapa}\label{mapa}}
